// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5053.RobotBuilderLisa.commands;

import edu.wpi.first.wpilibj.command.TimedCommand;
import org.usfirst.frc5053.RobotBuilderLisa.Robot;

/**
 *
 */
public class CatapultLaunch extends TimedCommand {
	double m_timeout;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR


    public CatapultLaunch() {
        this(0);
    }

    public CatapultLaunch(double timeout) {
        super(timeout);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        m_timeout = timeout;//we need to store this away so we an pass it into the timed throw because that is more accurate then this timer command that is only called ever 0.020 seconds (20 milli seconds)
        
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.catapult);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	Robot.catapult.lauchTimeLimited(m_timeout);

    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
    }


    // Called once after isFinished returns true
    @Override
    protected void end() {
    	// note this should be redundant, because the separate thrower-thread should have already started the solenoids retraction
    	Robot.catapult.arm();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	//nothing special to do so just call normal end() menthod
    	end();
    }
}
